-------------------------------------------------------------------------
-- Design unit: R8 simutation test bench
-- Description: R8 processor connected to a RAM memory
--      The RAM memory is able to load image files generated by the R8 simulator             
-------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;   

entity R8_uC_tb is
end R8_uC_tb;								 
																					 
architecture behavioral of R8_uC_tb is
    
	signal clk 			: std_logic := '0';  	
	signal rst			: std_logic := '0';
	signal portA_io		: std_logic_vector(15 downto 0);
	signal portB_io		: std_logic_vector(15 downto 0);	
	
	signal cryptoA_out	: std_logic_vector(7 downto 0);
	signal cryptoB_out	: std_logic_vector(7 downto 0);	
	
begin
	
	-- Simulation time of first teste: 7200 ns
	
	 -- Generates the clock signal            
    clk <= not clk after 10 ns;	   			-- 100 MHz
    
    -- Generates the reset signal
    rst <='1', '0' after 5 ns;   
	
	-- Flag test
	--portA_io <= "ZZZ0Z00010101010"; 				-- NONE FLAG IS ACTIVE
	--portA_io <= "ZZZ0Z01010101010";			   	-- DATA_AV FLAG IS ACTIVE
	--portA_io <= "ZZZ0Z10010101010";			   		-- KEYEXCHANGE FLAG IS ACTIVE
	--portA_io <= "ZZZ1Z00010101010"; 		   		-- EOM FLAG IS ACTIVE
	
	
	--========================================================================================================
	-- R8 Microcontroller
	--========================================================================================================
    uC_R8: entity work.R8_uC
		generic map(
			MEMORY_SIZE => 1024, 						-- Memory depth (number of words) -- x words (xKB)
			IMAGE		=> "crypto_message_simulation.txt"
		)
        port map (
            clk     	=> clk,
        	rst     	=> rst,
        	portA_io	=> portA_io,
			portB_io	=> portB_io
        );
		
	--========================================================================================================
	-- CryptoMessage Device
	--========================================================================================================
   	CryptoA: entity work.CryptoMessage
    	generic map(
        	MSG_INTERVAL    => 100,    				-- Clock cycles, idle time after send a complete message
        	FILE_NAME       => "DoctorRockter.txt"
    	)
    	port map( 
        	clk         	=> clk,
        	rst         	=> rst,
        	ack         	=> portA_io(11),
        	data_in     	=> portA_io(7 downto 0),
        	data_out    	=> cryptoA_out,
        	data_av     	=> portA_io(9), 
        	keyExchange 	=> portA_io(10),
        	eom         	=> portA_io(12)
    	);	
		
	-- Tristate - portA receives output from CryptoMessage when portA_io(8) = '0'
			--	  CryptoMessage receives data from portA when portA_io(8) = '1'
	portA_io(7 downto 0)	<=	cryptoA_out when portA_io(8) = '1' else
		   				   		"ZZZZZZZZ";

	CryptoB: entity work.CryptoMessage
    	generic map(
        	MSG_INTERVAL    => 100,    				-- Clock cycles, idle time after send a complete message
        	FILE_NAME       => "RevolutionCalling.txt"
    	)
    	port map( 
        	clk         	=> clk,
        	rst         	=> rst,
        	ack         	=> portB_io(11),
        	data_in     	=> portB_io(7 downto 0),
        	data_out    	=> cryptoB_out,
        	data_av     	=> portB_io(9), 
        	keyExchange 	=> portB_io(10),
        	eom         	=> portB_io(12)
    	);	 
	
	-- Tristate - portB receives output from CryptoMessage when portB_io(8) = '0'
			--	  CryptoMessage receives data from portB when portB_io(8) = '1'
	portB_io(7 downto 0)	<=	cryptoB_out when portB_io(8) = '1' else
		   				   		"ZZZZZZZZ";
		

	
	
    
end behavioral;