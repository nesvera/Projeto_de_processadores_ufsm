-------------------------------------------------------------------------
-- Design unit: R8 simutation test bench
-- Description: R8 processor connected to a RAM memory
--      The RAM memory is able to load image files generated by the R8 simulator             
-------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;  
use IEEE.std_logic_arith.CONV_STD_LOGIC_VECTOR;
use ieee.std_logic_unsigned.all; 	-- CONV_INTEGER function	
USE ieee.numeric_std.ALL;

entity R8_BRAM is
    port( 
        clk     : in std_logic;
        rst     : in std_logic;
        
        -- Display interface
        segments        : out std_logic_vector(7 downto 0);				-- Board display segments
        display_en_n    : out std_logic_vector(3 downto 0)	 			-- Display enable (active low)
    );
end R8_BRAM;    

architecture arch1 of R8_BRAM is
    
    signal clk_div2, clk_div2_n	: std_logic := '0';  
    signal rw, ce, ce_n, wr_n 	: std_logic; 
	signal ce_regDisp 			: std_logic;   
	signal regDisp_out 			: std_logic_vector(15 downto 0);	 
	  
	type BCDArray is array (0 to 3) of std_logic_vector(7 downto 0);
	signal bcd_to_disp: BCDArray;	
	  
	signal dataR8_out, dataR8_in, addressR8 : std_logic_vector(15 downto 0);    
    
begin
	DCM: entity work.ClockManager  								-- DCM spartan 6 	100MHz(In) -> 50MHz(Out)
		port map(			   	
			clk_in		=> clk,
			clk_div2	=> clk_div2
		);
	
    PROCESSOR: entity work.R8 
        port map (
            clk         => clk_div2, 
            rst         => rst, 
            data_in     => dataR8_in, 
            data_out    => dataR8_out, 
            address     => addressR8, 
            ce          => ce, 
            rw          => rw
        );
    
    RAM : entity work.Memory   
        generic map (			
			DATA_WIDTH  	=> 16,         						-- Data bus width			 	2 bytes word
        	ADDR_WIDTH  	=> 15,         						-- Address bus width  			32768 positions
        	IMAGE       	=> "Cronometro_R8_BRAM.txt"    		-- Memory content to be loaded    (text file)																											 
        )
        port map (
            clk     	=> clk_div2_n,
            wr    		=> wr_n,								-- Write Enable (1: write; 0: read) 
			en    		=> ce_n,								-- Memory enable
          	address 	=> addressR8(14 downto 0),
			data_in		=> dataR8_out,
			data_out	=> dataR8_in
        );	  			   
															  	-- Display register
	REGDISP: entity work.RegisterNbits
		generic map(
			WIDTH		=> 16,
			INIT_VALUE	=> 0		
		)
		port map(
			clk			=> clk_div2,
			rst			=> rst,
		  	ce			=> ce_regDisp,
			d			=> dataR8_out,
			q			=> regDisp_out						  
    	);
		
	BCD7SEG0: entity work.BCDConv								-- BCD decoders
		port map(
			d_in		=> regDisp_out(3 downto 0),
			d_out		=> bcd_to_disp(0)
		);
	
	BCD7SEG1: entity work.BCDConv
		port map(
			d_in		=> regDisp_out(7 downto 4),
			d_out		=> bcd_to_disp(1)
		);
		
	BCD7SEG2: entity work.BCDConv
		port map(
			d_in		=> regDisp_out(11 downto 8),
			d_out		=> bcd_to_disp(2)
		);
	
	BCD7SEG3: entity work.BCDConv
		port map(
			d_in		=> regDisp_out(15 downto 12),
			d_out		=> bcd_to_disp(3)
		);
		
	DispCtrl: entity work.DisplayCtrl
		port map(
			clk			=> clk_div2,
			rst			=> rst,
			display0    => bcd_to_disp(0),  -- Right most display
        	display1    => bcd_to_disp(1),
        	display2    => bcd_to_disp(2),
        	display3    => bcd_to_disp(3),   -- Left most display
        	segments    => segments,
        	display_en_n=> display_en_n
		);
		
    -- Clock signal 
	clk_div2_n	<= not clk_div2;
					
    -- Memory access control signals     
    ce_n <= (not addressR8(15)) and ce;							-- Enable memory when address(0x0000 - > 0x7FFF) and ce = 1     
    wr_n <= not rw;    											-- 
	
	-- Register to display control		 
	ce_regDisp	<= '1' when (addressR8 = x"8000") and rw = '0' and ce = '1' else '0';					-- Enable to write display value on register   
				
end arch1;